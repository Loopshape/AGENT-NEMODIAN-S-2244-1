<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nemodian 2244-1 :: Quantum Fractal AI Editor</title>
    <style>
        :root {
            --muted: #888;
            --info: #2196F3;
            --warn: #FF9800;
            --error: #F44336;
            --success: #4CAF50;
            --baseline: 1.5em;
            --header-h: calc(var(--baseline) * 1.6);
            --status-h: var(--baseline);
            --footer-h: calc(var(--baseline) * 2);
            --font-size: 13px;
            --ln-width: 50px;
            --theme-bg: #3a3c31;
            --panel: #313328;
            --header-bg: #2e3026;
            --status-bg: #22241e;
            --accent: #4ac94a;
            --muted-text: #999966;
            --err: #a03333;
            --warn-bg: #f0ad4e;
            --hover-blue: #3366a0;
            --info-bg: #5bc0de;
            --agent-nexus: #BB86FC;
            --agent-cognito: #03DAC6;
            --agent-relay: #FFD54F;
            --agent-sentinel: #CF6679;
            --agent-echo: #4ac94a;
            --quantum-glow: rgba(187, 134, 252, 0.6);
        }

        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Fira Code', monospace;
            font-size: var(--font-size);
            line-height: var(--baseline);
            background: var(--theme-bg);
            color: #f0f0e0;
            overflow: hidden;
        }

        body {
            display: grid;
            grid-template-rows: var(--header-h) var(--status-h) 1fr var(--footer-h);
        }

        header {
            grid-row: 1;
            grid-column: 1 / -1;
            background: var(--header-bg);
            border-bottom: 1px solid #22241e;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--quantum-glow), transparent);
            animation: quantumScan 3s infinite linear;
        }

        @keyframes quantumScan {
            0% { left: -100%; }
            100% { left: 100%; }
        }

        .quantum-pulse {
            animation: quantumPulse 2s infinite alternate;
        }

        .typing-active {
            caret-color: lime;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 50% { background-color: transparent; }
            51%, 100% { background-color: rgba(0,255,0,0.05); }
        }

        @keyframes quantumPulse {
            0% { opacity: 0.7; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.05); }
        }

        header .left {
            display: flex;
            gap: 12px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        header .right {
            display: flex;
            gap: 8px;
            align-items: center;
            position: relative;
            z-index: 2;
        }

        button {
            background: var(--err);
            border: 1px solid var(--err);
            color: #f0f0e0;
            padding: 6px 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all .2s;
            border-radius: 3px;
        }

        button:hover {
            background: var(--hover-blue);
            border-color: var(--hover-blue);
        }

        button.success {
            background: var(--accent);
            border-color: var(--accent);
        }

        button.info {
            background: var(--info-bg);
            border-color: var(--info-bg);
        }

        button.warn {
            background: var(--warn-bg);
            border-color: var(--warn-bg);
            color: #3a3c31;
        }

        #status-bar {
            grid-row: 2;
            grid-column: 1 / -1;
            background: var(--status-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 4px 12px;
            font-size: 12px;
            position: relative;
        }

        .quantum-threads {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        .quantum-thread {
            position: absolute;
            width: 1px;
            height: 100%;
            background: linear-gradient(to bottom, transparent, var(--agent-nexus), transparent);
            animation: threadFlow 2s infinite linear;
        }

        @keyframes threadFlow {
            0% { top: -100%; }
            100% { top: 100%; }
        }

        #editor-stage {
            grid-row: 3;
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 0px 1fr;
            background: var(--theme-bg);
            overflow: hidden;
            position: relative;
            transition: grid-template-columns 0.3s ease;
        }

        #editor-stage.left-panel-open {
            grid-template-columns: 240px 1fr;
        }

        #left-panel {
            background: var(--panel);
            border-right: 1px solid #22241e;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 8px;
            overflow: hidden;
            width: 240px;
        }

        .editor-container {
            position: relative;
            display: flex;
            flex: 1;
            background: var(--theme-bg);
            overflow: auto;
        }

        .line-numbers {
            width: var(--ln-width);
            padding: 10px 8px;
            background: var(--panel);
            color: var(--muted-text);
            font-variant-numeric: tabular-nums;
            text-align: right;
            user-select: none;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            flex-shrink: 0;
            position: sticky;
            left: 0;
            z-index: 10;
        }

        .editor-content {
            flex: 1;
            position: relative;
            min-height: 100%;
            padding: 10px;
            padding-left: 12px;
            box-sizing: border-box;
            white-space: pre;
            line-height: var(--baseline);
            font-family: inherit;
            font-size: inherit;
            tab-size: 4;
            -moz-tab-size: 4;
            caret-color: var(--accent);
            outline: none;
            overflow-wrap: normal;
            word-break: normal;
            overflow: auto;
        }

        .editor-content:focus {
            outline: none;
        }

        footer {
            grid-row: 4;
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 12px;
            background: var(--header-bg);
            border-top: 1px solid #22241e;
            position: sticky;
            bottom: 0;
        }

        #prompt-input {
            flex: 1;
            margin-right: 8px;
            padding: 8px;
            background: var(--status-bg);
            border: 1px solid var(--accent);
            color: #f0f0e0;
            font-family: inherit;
            border-radius: 3px;
            font-size: 16px;
        }

        .small {
            font-size: 12px;
            padding: 6px 8px;
        }

        .agent-card {
            background: var(--panel);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 4px solid var(--muted-text);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .agent-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .agent-card.active::before {
            left: 100%;
        }

        .agent-card.active {
            box-shadow: 0 0 20px var(--quantum-glow);
            transform: translateY(-2px);
        }

        .agent-card.nexus { border-left-color: var(--agent-nexus); }
        .agent-card.cognito { border-left-color: var(--agent-cognito); }
        .agent-card.relay { border-left-color: var(--agent-relay); }
        .agent-card.sentinel { border-left-color: var(--agent-sentinel); }
        .agent-card.echo { border-left-color: var(--agent-echo); }

        .agent-title {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .agent-nexus .agent-title { color: var(--agent-nexus); }
        .agent-cognito .agent-title { color: var(--agent-cognito); }
        .agent-relay .agent-title { color: var(--agent-relay); }
        .agent-sentinel .agent-title { color: var(--agent-sentinel); }
        .agent-echo .agent-title { color: var(--agent-echo); }

        .agent-subtitle {
            font-size: 11px;
            color: var(--muted-text);
            margin-bottom: 6px;
        }

        .agent-content {
            font-size: 12px;
            line-height: 1.4;
            min-height: 20px;
        }

        .quantum-spinner {
            width: 16px;
            height: 16px;
            display: inline-block;
            margin-right: 6px;
            position: relative;
        }

        .quantum-spinner::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-top: 2px solid var(--agent-cognito);
            border-radius: 50%;
            animation: quantumSpin 1s linear infinite;
        }

        .quantum-spinner::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border: 2px solid transparent;
            border-bottom: 2px solid var(--agent-nexus);
            border-radius: 50%;
            animation: quantumSpin 0.5s linear infinite;
        }

        @keyframes quantumSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .quantum-packet {
            position: fixed;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--agent-nexus);
            box-shadow: 0 0 10px var(--agent-nexus);
            opacity: 0;
            z-index: 100;
            pointer-events: none;
        }

        .quantum-trail {
            position: absolute;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--agent-nexus), transparent);
            opacity: 0;
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid var(--muted-text);
        }

        .action-buttons button {
            flex: 1;
            padding: 6px;
            font-size: 11px;
        }

        .quantum-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            margin-top: 5px;
        }

        .quantum-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--muted-text);
            position: relative;
        }

        .quantum-dot::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            border-radius: 50%;
            border: 1px solid var(--agent-nexus);
            animation: quantumPulseDot 2s infinite;
        }

        .quantum-dot.connected {
            background: var(--accent);
        }

        @keyframes quantumPulseDot {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }

        /* ========== SYNTAX HIGHLIGHTING STYLES ========== */
        .sh-token { transition: opacity 0.08s ease; pointer-events: none; }
        .sh-comment { color: #64748b; font-style: italic; opacity: 0.8; }
        .sh-string { color: #a3e635; font-weight: 500; }
        .sh-number { color: #f59e0b; font-weight: 600; }
        .sh-keyword { color: #f472b6; font-weight: 600; }
        .sh-type { color: #7dd3fc; font-weight: 500; }
        .sh-bracket { color: #c084fc; font-weight: 700; }
        .sh-id { color: #94a3b8; }
        .sh-op { color: #94a3b8; font-weight: 500; }
        .sh-ws { opacity: 0.3; }
        .sh-key { color: #7dd3fc; font-weight: 500; }
        .sh-number2 { color: #f59e0b; font-weight: 600; }
        .sh-text { color: #e2e8f0; }
        .sh-unknown { color: #f87171; }
        .sh-tag { color: #f472b6; font-weight: 600; }
        .sh-property { color: #7dd3fc; font-weight: 500; }
        .sh-function { color: #4ac94a; font-weight: 500; }
        .sh-operator { color: #93c5fd; font-weight: 600; }
        .sh-regex { color: #fbbf24; }
        .sh-html-entity { color: #f59e0b; }
        .sh-css-selector { color: #c084fc; }
        .sh-css-property { color: #60a5fa; }
        .sh-css-value { color: #34d399; }
        .sh-jsx-tag { color: #f472b6; }
        .sh-jsx-attribute { color: #7dd3fc; }
        .sh-template-string { color: #a3e635; font-weight: 500; }

        .editor-content::selection {
            background: rgba(74, 201, 74, 0.3);
        }

        .editor-container::-webkit-scrollbar {
            width: 12px;
        }

        .editor-container::-webkit-scrollbar-track {
            background: var(--panel);
        }

        .editor-container::-webkit-scrollbar-thumb {
            background: var(--muted-text);
            border-radius: 6px;
        }

        .editor-container::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        #preview-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 80%;
            background: white;
            border: 2px solid var(--accent);
            border-radius: 5px;
            z-index: 1000;
            display: none;
            flex-direction: column;
            box-shadow: 0 0 30px rgba(0,0,0,.7);
        }

        #preview-header {
            background: var(--header-bg);
            color: #f0f0e0;
            padding: 8px 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--accent);
        }

        #preview-content {
            width: 100%;
            height: calc(100% - 40px);
            border: none;
            background: white;
        }

        #close-preview {
            background: transparent;
            border: none;
            color: #f0f0e0;
            font-size: 18px;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #ai-response-panel {
            position: fixed;
            bottom: 60px;
            right: 20px;
            width: 500px;
            max-height: 600px;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 5px;
            padding: 15px;
            overflow-y: auto;
            z-index: 100;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,.3);
        }

        #ai-response-content {
            font-size: 12px;
            line-height: 1.4;
        }

        #close-ai-panel {
            position: absolute;
            top: 5px;
            right: 5px;
            background: transparent;
            border: none;
            color: var(--muted-text);
            font-size: 14px;
            cursor: pointer;
        }

        #file-input {
            display: none;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--accent);
            animation: none;
        }

        .ai-dot.probing {
            background: var(--err);
            animation: pulse 2s infinite;
        }

        .ai-dot.connected {
            background: var(--accent);
            animation: none;
        }

        .quantum-thinking {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .fractal-node {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: var(--agent-cognito);
            animation: fractalPulse 1.5s infinite alternate;
        }

        @keyframes fractalPulse {
            0% { transform: scale(1); opacity: 0.3; }
            100% { transform: scale(1.5); opacity: 0.8; }
        }

        @media (max-width: 768px) {
            #editor-stage {
                grid-template-columns: 1fr !important;
            }

            #left-panel {
                position: absolute;
                height: 100%;
                z-index: 30;
                transform: translateX(-240px);
            }

            #left-panel.open {
                transform: translateX(0);
            }

            #ai-response-panel {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }

            #preview-panel {
                width: 95%;
                height: 85%;
            }

            body {
                grid-template-rows: var(--header-h) var(--status-h) 1fr auto;
            }

            footer {
                position: relative;
            }
        }

        .consensus-panel {
            background: var(--panel);
            border: 1px solid var(--agent-nexus);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            max-height: 300px;
            overflow-y: auto;
        }

        .consensus-header {
            font-weight: bold;
            color: var(--agent-nexus);
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .candidate-item {
            background: rgba(255,255,255,0.05);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 8px;
            border-left: 3px solid var(--agent-cognito);
        }

        .candidate-meta {
            font-size: 10px;
            color: var(--muted-text);
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .candidate-content {
            font-size: 11px;
            font-family: 'Fira Code', monospace;
            white-space: pre-wrap;
            max-height: 80px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .entropy-badge {
            background: var(--agent-nexus);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        .selected-candidate {
            border-left-color: var(--accent);
            background: rgba(74, 201, 74, 0.1);
        }

        .orchestration-log {
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 8px;
            margin-top: 10px;
            max-height: 120px;
            overflow-y: auto;
            font-size: 10px;
            font-family: 'Fira Code', monospace;
        }

        .orchestration-log .log-entry {
            margin-bottom: 4px;
            padding-left: 10px;
            border-left: 2px solid var(--agent-nexus);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .orchestration-log .log-entry.genesis {
            border-left-color: var(--agent-nexus);
            color: var(--agent-nexus);
        }

        .orchestration-log .log-entry.origin {
            border-left-color: var(--agent-cognito);
            color: var(--agent-cognito);
        }

        .orchestration-log .log-entry.event {
            border-left-color: var(--agent-relay);
            color: var(--agent-relay);
        }

        .orchestration-log .log-entry.fragment {
            border-left-color: var(--agent-sentinel);
            color: var(--agent-sentinel);
        }

        .orchestration-log .log-entry.consensus {
            border-left-color: var(--agent-echo);
            color: var(--agent-echo);
        }

        .memory-status {
            font-size: 10px;
            color: var(--muted-text);
            padding: 2px 6px;
            border-radius: 3px;
            background: rgba(0,0,0,0.3);
        }

        .memory-status.low {
            color: #f87171;
            background: rgba(248, 113, 113, 0.1);
        }

        .memory-status.warning {
            color: #f59e0b;
            background: rgba(245, 158, 11, 0.1);
        }

        .memory-status.good {
            color: #4ac94a;
        }

        .suggestion-item {
            padding: 8px;
            border-bottom: 1px solid var(--muted-text);
            cursor: pointer;
            transition: background 0.2s;
        }

        .suggestion-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .suggestion-item:last-child {
            border-bottom: none;
        }

        #suggestions-panel {
            position: absolute;
            background: var(--panel);
            border: 1px solid var(--accent);
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
<header>
    <div class="left">
        <button id="left-toggle" class="small">☰</button>
        <div style="font-weight:800;" class="quantum-pulse">Nemodian 2244-1 :: Quantum Fractal AI</div>
    </div>
    <div class="right">
        <div class="ai-status">
            <div id="ai-dot" class="ai-dot connected"></div>
            <div id="ai-indicator" style="font-size:12px;color:#cfcfbd;">Quantum AI: Ready</div>
        </div>
        <button id="open-file" class="small">Open</button>
        <button id="save-file" class="small">Save</button>
        <button id="save-as" class="small">Save As</button>
        <button id="render-html" class="small warn">Render HTML</button>
        <button id="run-local-ai" class="small info">Quantum AI</button>
        <button id="run-orchestrator" class="small success">Orchestrator</button>
    </div>
</header>
<div id="status-bar" class="info">
    <div class="quantum-threads" id="quantum-threads"></div>
    <div id="file-meta">No File Loaded</div>
    <div id="editor-meta">Cursor: 0:0 | Lines: 0 | Chars: 0 | History: 0</div>
    <div id="memory-status" class="memory-status good">RAM: OK</div>
</div>
<div id="editor-stage">
    <aside id="left-panel" class="closed">
        <button id="btn-undo" class="small">UNDO</button>
        <button id="btn-redo" class="small">REDO</button>
        <button id="btn-beautify" class="small">Beautify</button>
        <button id="btn-render" class="small warn">Render HTML</button>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum AI Commands:</strong></p>
            <ul style="padding-left: 15px;">
                <li>Rewrite this function</li>
                <li>Optimize performance</li>
                <li>Add error handling</li>
                <li>Convert to TypeScript</li>
                <li>Explain this code</li>
            </ul>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Actions:</strong></p>
            <button id="btn-optimize" class="small" style="width:100%;margin-bottom:5px;">Quantum Optimize</button>
            <button id="btn-document" class="small" style="width:100%;margin-bottom:5px;">Fractal Document</button>
            <button id="btn-refactor" class="small" style="width:100%;">Hyper Refactor</button>
            <button id="btn-orchestrate" class="small success" style="width:100%;margin-top:5px;">Multi-Agent Consensus</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Memory Management:</strong></p>
            <button id="btn-clear-cache" class="small" style="width:100%;margin-bottom:5px;">Clear Cache</button>
            <button id="btn-optimize-memory" class="small info" style="width:100%;margin-bottom:5px;">Optimize Memory</button>
            <button id="btn-export-session" class="small" style="width:100%;">Export Session</button>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Quantum Settings:</strong></p>
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 5px;">
                <input type="checkbox" id="quantum-mode" checked>
                <label for="quantum-mode">Quantum Fractal Mode</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="hyperthreading" checked>
                <label for="hyperthreading">Hyperthreading</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="multi-agent-mode" checked>
                <label for="multi-agent-mode">Multi-Agent Consensus</label>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; margin-top: 5px;">
                <input type="checkbox" id="auto-save" checked>
                <label for="auto-save">Auto Save</label>
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Orchestrator Settings:</strong></p>
            <div style="margin-bottom: 5px;">
                <label for="agent-count">Agent Count:</label>
                <input type="number" id="agent-count" min="2" max="8" value="5" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="max-rounds">Max Rounds:</label>
                <input type="number" id="max-rounds" min="1" max="10" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
            <div style="margin-bottom: 5px;">
                <label for="reasoning-depth">Reasoning Depth:</label>
                <input type="number" id="reasoning-depth" min="1" max="5" value="3" style="width: 60px; background: var(--status-bg); color: white; border: 1px solid var(--muted-text); padding: 2px; border-radius: 3px;">
            </div>
        </div>

        <div style="margin-top: 20px; font-size: 11px; color: var(--muted-text);">
            <p><strong>Recent Files:</strong></p>
            <div id="recent-files" style="max-height: 100px; overflow-y: auto;">
                <!-- Recent files will be populated here -->
            </div>
        </div>
    </aside>

    <!-- Quantum Editor Container -->
    <div class="editor-container">
        <div class="quantum-thinking" id="quantum-thinking"></div>
        <div class="line-numbers" id="line-numbers"></div>
        <div
            class="editor-content"
            id="editor"
            contenteditable="true"
            spellcheck="false"
            data-gramm="false"
            data-gramm_editor="false"
            data-enable-grammarly="false"
        >// Quantum Fractal AI Editor - Ready
// Start coding or use the prompt below for AI assistance

function welcome() {
    return "Welcome to the Quantum Fractal AI Editor!";
}</div>
    </div>
</div>
<footer>
    <input id="prompt-input" placeholder="Enter quantum command (e.g., 'create a function to sort arrays')">
    <button id="send-button" class="success">QUANTUM PROCESS</button>
</footer>

<!-- Hidden elements -->
<input type="file" id="file-input" accept=".js,.html,.css,.txt,.json,.ts,.jsx,.tsx,.py,.php,.sql,.md,.xml,.yaml,.yml">
<div id="suggestions-panel"></div>

<!-- Panels -->
<div id="preview-panel">
    <div id="preview-header">
        <span>Quantum Preview</span>
        <button id="close-preview">×</button>
    </div>
    <iframe id="preview-content"></iframe>
</div>

<div id="ai-response-panel">
    <button id="close-ai-panel">×</button>
    <div id="ai-response-content">
        <div class="agent-card nexus agent-nexus">
            <div class="agent-title">Nexus</div>
            <div class="agent-subtitle">Core</div>
            <div class="agent-content">Idle. Awaiting quantum command.</div>
            <div class="orchestration-log" id="nexus-log"></div>
            <div class="quantum-status">
                <div class="quantum-dot connected"></div>
                <span>Quantum State: Entangled</span>
            </div>
        </div>
        <div class="agent-card cognito agent-cognito">
            <div class="agent-title">Cognito</div>
            <div class="agent-subtitle">Loop</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="cognito-log"></div>
        </div>
        <div class="agent-card relay agent-relay">
            <div class="agent-title">Relay</div>
            <div class="agent-subtitle">2244</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="relay-log"></div>
        </div>
        <div class="agent-card sentinel agent-sentinel">
            <div class="agent-title">Sentinel</div>
            <div class="agent-subtitle">Coin</div>
            <div class="agent-content">Ready</div>
            <div class="orchestration-log" id="sentinel-log"></div>
        </div>
        <div class="agent-card echo agent-echo">
            <div class="agent-title">Echo</div>
            <div class="agent-subtitle">Code</div>
            <div class="agent-content">Awaiting quantum report...</div>
            <div class="orchestration-log" id="echo-log"></div>
        </div>
        <div class="consensus-panel" id="consensus-panel" style="display: none;">
            <div class="consensus-header">
                <span>Multi-Agent Consensus Results</span>
                <span class="entropy-badge" id="consensus-score">Score: 0</span>
            </div>
            <div id="candidates-list"></div>
        </div>
    </div>
</div>

<!-- GSAP for animations -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

<script>
    /* =========================================================================
       QUANTUM FRACTAL AI EDITOR - FULL FUNCTIONALITY
       ========================================================================== */

    // Global state
    window.quantumState = {
        isGenerating: false,
        isSpeaking: false,
        currentSession: null,
        recentFiles: [],
        settings: {
            quantumMode: true,
            hyperthreading: true,
            multiAgentMode: true,
            autoSave: true,
            agentCount: 5,
            maxRounds: 3,
            reasoningDepth: 3
        }
    };

    /* =========================================================================
       MEMORY MANAGER - Enhanced with Full Features
       ========================================================================== */

    class QuantumMemoryManager {
        constructor() {
            this.storageKey = 'quantum_editor_cache';
            this.settingsKey = 'quantum_editor_settings';
            this.recentFilesKey = 'quantum_recent_files';
            this.maxMemoryThreshold = 50 * 1024 * 1024;
            this.cacheLimit = 40960;
            this.memoryStatus = document.getElementById('memory-status');
            this.cleanupInterval = null;

            this.init();
        }

        init() {
            this.loadSettings();
            this.loadRecentFiles();
            this.startMemoryMonitoring();
            this.cleanupOldCache();
        }

        startMemoryMonitoring() {
            this.cleanupInterval = setInterval(() => {
                this.checkMemoryUsage();
            }, 3200);

            window.addEventListener('beforeunload', () => this.cleanup());
        }

        async checkMemoryUsage() {
            try {
                if ('memory' in performance) {
                    const memory = performance.memory;
                    const used = memory.usedJSHeapSize;
                    const limit = memory.jsHeapSizeLimit;

                    const usagePercent = (used / limit) * 100;

                    if (usagePercent > 80) {
                        this.memoryStatus.textContent = 'RAM: CRITICAL';
                        this.memoryStatus.className = 'memory-status low';
                        this.emergencyCleanup();
                    } else if (usagePercent > 60) {
                        this.memoryStatus.textContent = 'RAM: WARNING';
                        this.memoryStatus.className = 'memory-status warning';
                        this.aggressiveCleanup();
                    } else {
                        this.memoryStatus.textContent = 'RAM: OK';
                        this.memoryStatus.className = 'memory-status good';
                    }
                }
            } catch (error) {
                console.warn('Memory monitoring unavailable:', error);
            }
        }

        loadSettings() {
            try {
                const stored = localStorage.getItem(this.settingsKey);
                if (stored) {
                    const settings = JSON.parse(stored);
                    window.quantumState.settings = { ...window.quantumState.settings, ...settings };
                    this.applySettings();
                }
            } catch (error) {
                console.warn('Settings load failed:', error);
            }
        }

        saveSettings() {
            try {
                localStorage.setItem(this.settingsKey, JSON.stringify(window.quantumState.settings));
            } catch (error) {
                console.warn('Settings save failed:', error);
            }
        }

        applySettings() {
            const settings = window.quantumState.settings;
            document.getElementById('quantum-mode').checked = settings.quantumMode;
            document.getElementById('hyperthreading').checked = settings.hyperthreading;
            document.getElementById('multi-agent-mode').checked = settings.multiAgentMode;
            document.getElementById('auto-save').checked = settings.autoSave;
            document.getElementById('agent-count').value = settings.agentCount;
            document.getElementById('max-rounds').value = settings.maxRounds;
            document.getElementById('reasoning-depth').value = settings.reasoningDepth;
        }

        loadRecentFiles() {
            try {
                const stored = localStorage.getItem(this.recentFilesKey);
                if (stored) {
                    window.quantumState.recentFiles = JSON.parse(stored);
                    this.updateRecentFilesUI();
                }
            } catch (error) {
                console.warn('Recent files load failed:', error);
            }
        }

        saveRecentFiles() {
            try {
                localStorage.setItem(this.recentFilesKey, JSON.stringify(window.quantumState.recentFiles));
            } catch (error) {
                console.warn('Recent files save failed:', error);
            }
        }

        addRecentFile(filename, content) {
            window.quantumState.recentFiles = window.quantumState.recentFiles.filter(f => f.filename !== filename);
            window.quantumState.recentFiles.unshift({
                filename,
                content: content.substring(0, 1000),
                timestamp: Date.now()
            });
            window.quantumState.recentFiles = window.quantumState.recentFiles.slice(0, 10);
            this.saveRecentFiles();
            this.updateRecentFilesUI();
        }

        updateRecentFilesUI() {
            const container = document.getElementById('recent-files');
            container.innerHTML = '';
            window.quantumState.recentFiles.forEach(file => {
                const item = document.createElement('div');
                item.className = 'suggestion-item';
                item.innerHTML = `
                    <div style="font-weight: bold;">${file.filename}</div>
                    <div style="font-size: 9px; color: var(--muted-text);">${new Date(file.timestamp).toLocaleDateString()}</div>
                `;
                item.addEventListener('click', () => {
                    quantumEditor.setContent(file.content, quantumEditor.highlighter.detectLanguage(file.filename));
                    document.getElementById('file-meta').textContent = file.filename;
                    quantumEditor.currentFileName = file.filename;
                });
                container.appendChild(item);
            });
            if (window.quantumState.recentFiles.length === 0) {
                container.innerHTML = '<div style="padding: 8px; color: var(--muted-text); font-size: 10px;">No recent files</div>';
            }
        }

        async store(key, data, priority = 'medium') {
            try {
                const cache = this.getCache();
                const dataSize = new Blob([JSON.stringify(data)]).size;
                if (dataSize > this.maxMemoryThreshold) {
                    throw new Error('Data too large for storage');
                }
                cache[key] = { data, timestamp: Date.now(), priority, size: dataSize };
                if (Object.keys(cache).length > this.cacheLimit) this.cleanupCache();
                await this.saveCache(cache);
                return true;
            } catch (error) {
                console.warn('Storage failed, falling back to memory:', error);
                if (!window.quantumMemoryCache) window.quantumMemoryCache = new Map();
                window.quantumMemoryCache.set(key, data);
                return false;
            }
        }

        async retrieve(key) {
            try {
                const cache = this.getCache();
                if (cache[key]) return cache[key].data;
                if (window.quantumMemoryCache && window.quantumMemoryCache.has(key)) return window.quantumMemoryCache.get(key);
                return null;
            } catch (error) {
                console.warn('Retrieval failed:', error);
                return null;
            }
        }

        cleanupCache() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                if (entries.length > this.cacheLimit) {
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toRemove = entries.slice(0, Math.floor(entries.length * 0.3));
                    toRemove.forEach(([key]) => delete cache[key]);
                    this.saveCache(cache);
                }
            } catch (error) {
                console.warn('Cache cleanup failed:', error);
            }
        }

        emergencyCleanup() {
            try {
                localStorage.removeItem(this.storageKey);
                sessionStorage.clear();
                if (window.quantumMemoryCache) window.quantumMemoryCache.clear();
                if (window.gc) window.gc();
                this.clearLargeArrays();
                console.log('Emergency memory cleanup completed');
            } catch (error) {
                console.error('Emergency cleanup failed:', error);
            }
        }

        aggressiveCleanup() {
            try {
                const cache = this.getCache();
                const entries = Object.entries(cache);
                const toKeep = entries.filter(([, entry]) => entry.priority === 'high' && entry.size < 1024 * 1024);
                this.saveCache(Object.fromEntries(toKeep));
                if (window.quantumMemoryCache) {
                    const keys = Array.from(window.quantumMemoryCache.keys());
                    keys.slice(0, Math.floor(keys.length * 0.5)).forEach(key => window.quantumMemoryCache.delete(key));
                }
                console.log('Aggressive memory cleanup completed');
            } catch (error) {
                console.warn('Aggressive cleanup failed:', error);
            }
        }

        clearLargeArrays() {
            if (window.largeArrays) window.largeArrays.clear();
        }

        cleanupOldCache() {
            const cache = this.getCache();
            const now = Date.now();
            const oneHour = 60 * 60 * 1000;
            Object.keys(cache).forEach(key => {
                if (now - cache[key].timestamp > oneHour) delete cache[key];
            });
            this.saveCache(cache);
        }

        getCache() {
            try {
                const stored = localStorage.getItem(this.storageKey);
                return stored ? JSON.parse(stored) : {};
            } catch (error) {
                console.warn('Cache retrieval failed:', error);
                return {};
            }
        }

        async saveCache(cache) {
            try {
                localStorage.setItem(this.storageKey, JSON.stringify(cache));
            } catch (error) {
                console.warn('Cache save failed:', error);
            }
        }

        cleanup() {
            if (this.cleanupInterval) clearInterval(this.cleanupInterval);
        }

        async exportSession() {
            try {
                const sessionData = {
                    timestamp: Date.now(),
                    cache: this.getCache(),
                    memoryCache: window.quantumMemoryCache ? Array.from(window.quantumMemoryCache.entries()) : [],
                    recentFiles: window.quantumState.recentFiles,
                    settings: window.quantumState.settings
                };
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `quantum_session_${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
                return true;
            } catch (error) {
                console.error('Session export failed:', error);
                return false;
            }
        }

        async clearAllCache() {
            try {
                localStorage.removeItem(this.storageKey);
                localStorage.removeItem(this.settingsKey);
                localStorage.removeItem(this.recentFilesKey);
                if (window.quantumMemoryCache) window.quantumMemoryCache.clear();
                sessionStorage.clear();
                return true;
            } catch (error) {
                console.error('Cache clearance failed:', error);
                return false;
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM SYNTAX HIGHLIGHTER
       ========================================================================== */

    class QuantumSyntaxHighlighter {
        constructor() {
            this.languagePatterns = {
                javascript: this.getJavaScriptPatterns(),
                html: this.getHTMLPatterns(),
                css: this.getCSSPatterns(),
                python: this.getPythonPatterns(),
                json: this.getJSONPatterns(),
            };
            this.currentLanguage = 'javascript';
        }

        getJavaScriptPatterns() {
          return [
                { pattern: /\/\/.*$/gm, type: 'comment' },
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /`(?:\\.|[^`\\])*`/g, type: 'template-string' },
                { pattern: /'(?:\\.|[^'\\])*'/g, type: 'string' },
                { pattern: /"(?:\\.|[^"\\])*"/g, type: 'string' },
                { pattern: /\/(?![*\/])(?:\\.|[^\/\\\n])+\/[gimuy]*/g, type: 'regex' },
                { pattern: /\b(0x[a-fA-F0-9]+|(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?)\b/g, type: 'number' },
                { pattern: /\b(?:function|class|const|let|var|if|else|for|while|do|switch|case|break|continue|return|try|catch|finally|throw|new|this|super|extends|import|export|from|default|async|await|yield|static|public|private|protected|of|in|instanceof|typeof)\b/g, type: 'keyword' },
                { pattern: /\b(true|false|null|undefined)\b/g, type: 'keyword' },
                { pattern: /\b(?:console|Math|Date|Array|Object|String|Number|Boolean|Promise|JSON)\b/g, type: 'type' },
                { pattern: /[a-zA-Z_$][\w$]*(?=\s*=\s*function|[a-zA-Z_$][\w$]*\s*=>|\s*\()/g, type: 'function' },
                { pattern: /[+\-*/%=<>!&|^~?:.,;]/g, type: 'operator' },
                { pattern: /[{}()[\]]/g, type: 'bracket' }
            ];
        }

        getHTMLPatterns() {
            return [
                { pattern: /<!--[\s\S]*?-->/g, type: 'comment' },
                { pattern: /<\/?[\w\d\-]+(?=\s|>|\/)/g, type: 'tag' },
                { pattern: /[\w\d\-]+(?=\s*=)/g, type: 'property' },
                { pattern: /"(?:\\.|[^"])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'])*'/g, type: 'string' }
            ];
        }

        getCSSPatterns() {
            return [
                { pattern: /\/\*[\s\S]*?\*\//g, type: 'comment' },
                { pattern: /(?<=@)[\w\d\-]+/g, type: 'keyword' },
                { pattern: /(?:[#.]?[\w\d\-_]+|::?[\w\d\-]+)(?=\s*[{,])/g, type: 'css-selector' },
                { pattern: /[\w\d\-]+(?=\s*:)/g, type: 'css-property' },
                { pattern: /"(?:\\.|[^"])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'])*'/g, type: 'string' },
                { pattern: /#[\da-f]{3,8}\b/gi, type: 'number' },
                { pattern: /\b\d+(?:\.\d+)?(?:px|em|rem|%|vw|vh|s|ms|deg)?\b/g, type: 'number' },
            ];
        }

        getPythonPatterns() {
            return [
                { pattern: /#.*$/gm, type: 'comment' },
                { pattern: /"""[\s\S]*?"""/g, type: 'string' },
                { pattern: /'''[\s\S]*?'''/g, type: 'string' },
                { pattern: /"(?:\\.|[^"])*"/g, type: 'string' },
                { pattern: /'(?:\\.|[^'])*'/g, type: 'string' },
                { pattern: /\b\d+(\.\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:def|class|if|elif|else|for|while|try|except|finally|with|import|from|as|return|yield|async|await|lambda|None|True|False|and|or|not|in|is|global|nonlocal|del|pass|break|continue|raise)\b/g, type: 'keyword' },
                { pattern: /\b[a-zA-Z_]\w*(?=\s*\()/g, type: 'function' },
                { pattern: /@\w+/g, type: 'function' }
            ];
        }

        getJSONPatterns() {
            return [
                { pattern: /"(?:\\.|[^"])*"(?=\s*:)/g, type: 'key' },
                { pattern: /"(?:\\.|[^"])*"/g, type: 'string' },
                { pattern: /\b-?(?:\d+(\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?\b/g, type: 'number' },
                { pattern: /\b(?:true|false|null)\b/g, type: 'keyword' }
            ];
        }

        detectLanguage(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const languageMap = { 'js': 'javascript', 'html': 'html', 'css': 'css', 'py': 'python', 'json': 'json', 'txt': 'javascript' };
            return languageMap[ext] || 'html';
        }

        escapeHtml(text) {
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        highlightText(text, language) {
            const lang = language || this.currentLanguage;
            const patterns = this.languagePatterns[lang] || this.languagePatterns.javascript;
            let highlighted = this.escapeHtml(text);
            patterns.forEach(({ pattern, type }) => {
                highlighted = '<span class="sh-token sh-${type}"> + highlighted.replace(pattern, match => `${match}`) + </span>';
            });
            return highlighted;
        }

        highlightElement(element, language) {
            const text = element.textContent;
            const highlightedHtml = this.highlightText(text, language);
            const selection = window.getSelection();
            const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
            if (range) {
                const { startContainer, startOffset, endContainer, endOffset } = range;
                const tempEl = document.createElement('div');
                tempEl.innerHTML = highlightedHtml;
                element.innerHTML = '';
                while (tempEl.firstChild) {
                    element.appendChild(tempEl.firstChild);
                }

                try {
                    const newRange = document.createRange();
                    // This is a naive way to restore selection and may not work for complex cases
                    newRange.setStart(element.firstChild || element, Math.min(startOffset, element.textContent.length));
                    newRange.setEnd(element.firstChild || element, Math.min(endOffset, element.textContent.length));
                    selection.removeAllRanges();
                    selection.addRange(newRange);
                } catch(e) { /* Range might be invalid after highlight */ }
            } else {
                 element.innerHTML = highlightedHtml;
            }
        }
    }

    /* =========================================================================
       ENHANCED QUANTUM EDITOR WITH COMPLETE FEATURES
       ========================================================================== */

    class QuantumEditor {
        constructor() {
            this.editor = document.getElementById('editor');
            this.lineNumbers = document.getElementById('line-numbers');
            this.statusEditor = document.getElementById('editor-meta');
            this.statusFile = document.getElementById('file-meta');
            this.memoryManager = memoryManager;
            this.highlighter = new QuantumSyntaxHighlighter();
            this.quantumThinking = document.getElementById('quantum-thinking');

            this.currentFileName = null;
            this.currentFileType = 'javascript';
            this.historyStack = [];
            this.redoStack = [];
            this.maxHistorySize = 100;

            this.init();
        }

        init() {
            this.bindEvents();
            this.pushHistory();
            this.updateLineNumbers();
            this.updateStatus();
            this.highlighter.highlightElement(this.editor, this.currentFileType);
            this.startAutoSave();
            this.initQuantumVisuals();
        }
        
        startAutoSave() {
            setInterval(() => {
                if(window.quantumState.settings.autoSave) this.saveAutosave();
            }, 30000);
        }

        saveAutosave() {
            const content = this.getContent();
            if(content.trim()) {
                this.memoryManager.store('autosave_content', content, 'high');
            }
        }

        bindEvents() {
            this.editor.addEventListener('input', () => this.handleInput());
            this.editor.addEventListener('keydown', (e) => this.handleKeydown(e));
            this.editor.addEventListener('click', () => this.updateStatus());
            this.editor.addEventListener('keyup', () => this.updateStatus());
            this.editor.addEventListener('scroll', () => this.syncScroll());
        }

        handleInput() {
            this.pushHistory();
            this.updateLineNumbers();
            this.updateStatus();
            this.highlighter.highlightElement(this.editor, this.currentFileType);
        }

        handleKeydown(event) {
            if (event.key === 'Tab') {
                event.preventDefault();
                document.execCommand('insertText', false, '    ');
            }
            if (event.ctrlKey || event.metaKey) {
                if (event.key === 'z') { event.preventDefault(); this.undo(); }
                if (event.key === 'y' || (event.shiftKey && event.key === 'z')) { event.preventDefault(); this.redo(); }
                if (event.key === 's') { event.preventDefault(); quantumSaveFile(); }
            }
        }

        pushHistory() {
            const content = this.getContent();
            if (this.historyStack.length && this.historyStack[this.historyStack.length - 1] === content) return;
            this.historyStack.push(content);
            if (this.historyStack.length > this.maxHistorySize) this.historyStack.shift();
            this.redoStack = [];
        }

        undo() {
            if (this.historyStack.length > 1) {
                this.redoStack.push(this.historyStack.pop());
                this.setContent(this.historyStack[this.historyStack.length - 1], this.currentFileType, false);
            }
        }

        redo() {
            if (this.redoStack.length > 0) {
                const content = this.redoStack.pop();
                this.historyStack.push(content);
                this.setContent(content, this.currentFileType, false);
            }
        }

        updateLineNumbers() {
            const lineCount = this.getContent().split('\n').length;
            this.lineNumbers.innerHTML = Array.from({length: lineCount}, (_, i) => i + 1).join('<br>');
        }
        
        syncScroll() {
            this.lineNumbers.scrollTop = this.editor.scrollTop;
        }

        updateStatus() {
            const content = this.getContent();
            const lines = content.split('\n').length;
            const chars = content.length;
            const selection = window.getSelection();
            let cursor = '1:1';
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(this.editor);
                preCaretRange.setEnd(range.startContainer, range.startOffset);
                const preCaretLines = preCaretRange.toString().split('\n');
                cursor = `${preCaretLines.length}:${preCaretLines[preCaretLines.length - 1].length + 1}`;
            }
            this.statusEditor.textContent = `Cursor: ${cursor} | Lines: ${lines} | Chars: ${chars} | History: ${this.historyStack.length}`;
        }

        setContent(content, fileType, addToHistory = true) {
            this.currentFileType = fileType;
            this.highlighter.currentLanguage = fileType;
            this.editor.textContent = content;
            this.updateLineNumbers();
            this.updateStatus();
            this.highlighter.highlightElement(this.editor, fileType);
            if (addToHistory) {
                this.historyStack = [content];
                this.redoStack = [];
            }
        }

        getContent() { return this.editor.textContent; }

        getSelectedText() {
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const text = range.toString();
                if (text.length > 0) {
                    return text;
                }
            }
            return this.getContent(); // Fallback to all content
        }
        
        initQuantumVisuals() {
            const threadsContainer = document.getElementById('quantum-threads');
            for (let i = 0; i < 5; i++) {
                const thread = document.createElement('div');
                thread.className = 'quantum-thread';
                thread.style.left = `${20 + i * 15}%`;
                thread.style.animationDelay = `${i * 0.3}s`;
                threadsContainer.appendChild(thread);
            }
        }
        
        beautifyCode() {
            try {
                const code = this.getContent();
                let formattedCode = '';
                let indentLevel = 0;
                const indentChar = '    ';

                const lines = code.split('\n');
                lines.forEach(line => {
                    let trimmedLine = line.trim();
                    if (trimmedLine.startsWith('}') || trimmedLine.startsWith(']') || trimmedLine.startsWith(')')) {
                        indentLevel = Math.max(0, indentLevel - 1);
                    }
                    
                    if(trimmedLine.length > 0) {
                        formattedCode += indentChar.repeat(indentLevel) + trimmedLine + '\n';
                    }

                    if (trimmedLine.endsWith('{') || trimmedLine.endsWith('[') || trimmedLine.endsWith('(')) {
                        indentLevel++;
                    }
                });
                
                this.setContent(formattedCode.trim(), this.currentFileType);
                quantumNotify('Code beautified.', 'success');
            } catch (e) {
                console.error('Beautify failed:', e);
                quantumNotify('Beautification failed.', 'error');
            }
        }
    }

    /* =========================================================================
       20-STEP GENESIS-ROOTED QUANTUM ORCHESTRATOR
       ========================================================================== */
    class EnhancedQuantumOrchestrator {
        constructor() {
            this.agents = {
                nexus: { el: document.querySelector('.agent-nexus .agent-content'), logEl: document.getElementById('nexus-log'), cardEl: document.querySelector('.agent-nexus') },
                cognito: { el: document.querySelector('.agent-cognito .agent-content'), logEl: document.getElementById('cognito-log'), cardEl: document.querySelector('.agent-cognito') },
                relay: { el: document.querySelector('.agent-relay .agent-content'), logEl: document.getElementById('relay-log'), cardEl: document.querySelector('.agent-relay') },
                sentinel: { el: document.querySelector('.agent-sentinel .agent-content'), logEl: document.getElementById('sentinel-log'), cardEl: document.querySelector('.agent-sentinel') },
                echo: { el: document.querySelector('.agent-echo .agent-content'), logEl: document.getElementById('echo-log'), cardEl: document.querySelector('.agent-echo') }
            };
            this.consensusPanel = document.getElementById('consensus-panel');
            this.candidatesList = document.getElementById('candidates-list');
            this.consensusScore = document.getElementById('consensus-score');
            this.isGenerating = false;
            this.sessionData = {};
            this.highlighter = new QuantumSyntaxHighlighter();
        }

        _initializeUIForRun() {
            document.getElementById('ai-response-panel').style.display = 'block';
            this.consensusPanel.style.display = 'none';
            this.candidatesList.innerHTML = '';
            Object.values(this.agents).forEach(a => {
                a.el.textContent = 'Awaiting Instructions...';
                a.logEl.innerHTML = '';
                a.cardEl.classList.remove('active');
            });
        }
        
        async _updateUI(agentName, message, logType = 'info', status = 'working') {
            const agent = this.agents[agentName];
            if (!agent) return;

            let spinner = status === 'working' ? '<div class="quantum-spinner"></div>' : '';
            agent.el.innerHTML = `${spinner}${message}`;

            if (logType) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${logType}`;
                logEntry.innerHTML = `[${timestamp}] ${message}`;
                agent.logEl.appendChild(logEntry);
                agent.logEl.scrollTop = agent.logEl.scrollHeight;
            }

            Object.values(this.agents).forEach(a => a.cardEl.classList.remove('active'));
            if (status === 'working') {
                agent.cardEl.classList.add('active');
            }
        }

        async _sha256(str) {
            const buffer = new TextEncoder().encode(str);
            const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }
        
        _calculateEntropy(str) {
            const counts = {};
            for (const char of str) {
                counts[char] = (counts[char] || 0) + 1;
            }
            return Object.values(counts).reduce((sum, count) => {
                const p = count / str.length;
                return sum - p * Math.log2(p);
            }, 0);
        }

        async runOrchestration(prompt, context) {
            if (this.isGenerating) {
                quantumNotify('Orchestration already in progress.', 'warn');
                return;
            }
            this.isGenerating = true;
            this._initializeUIForRun();
            
            // Initialize session data, making it the single source of truth for the run
            this.sessionData = {
                prompt,
                context,
                memoryCounter: this.sessionData.memoryCounter || 0 // Persist counter across runs
            };

            try {
                // PHASE 1: Genesis Foundation
                await this._step1_generateGenesisHash();
                await this._step2_createAgentOrigins();
                await this._step3_deconstructPrompt();
                await this._step4_parallelReasoning();
                await this._step5_memoryStaging();
                
                // PHASE 2: Collaborative Acceleration
                await this._step6_accelerateReasoning();
                await this._step7_enforceCollaboration();
                await this._step8_injectThinking();
                await this._step9_sourceFinalAnswer();
                await this._step10_integrateTokens();
                
                // PHASE 3: Backtraced Finalization
                await this._step11_verifyGenesisChain();
                await this._step12_and_13_consensusAndEntropy();
                await this._step14_verifyPromptAlignment();
                await this._step15_validateCodeQuality();
                await this._step16_optimizePerformance();
                await this._step17_assessSecurity();
                await this._step18_generateDocumentation();
                await this._step19_integrateUX();
                await this._step20_archiveSession();

            } catch (error) {
                console.error("Orchestration failed:", error);
                this._updateUI('nexus', `Critical Error: ${error.message}`, 'error', 'error');
            } finally {
                this.isGenerating = false;
            }
        }
        
        // Step Implementations
        async _step1_generateGenesisHash() {
            await this._updateUI('nexus', 'Generating Universal Genesis Hash...', 'genesis');
            const hash = await this._sha256(this.sessionData.prompt + Date.now() + Math.random());
            await this._updateUI('nexus', `Genesis Hash established: ${hash.substring(0,12)}...`, 'genesis', 'done');
            this.sessionData.genesisHash = hash;
        }

        async _step2_createAgentOrigins() {
            await this._updateUI('cognito', 'Creating Agent-Specific Origin Hashes...', 'origin');
            const agentCount = window.quantumState.settings.agentCount;
            const origins = [];
            for (let i = 0; i < agentCount; i++) {
                const agentId = `agent_${i}`;
                const originHash = await this._sha256(this.sessionData.genesisHash + agentId + i);
                const entropy = this._calculateEntropy(originHash);
                origins.push({ id: agentId, hash: originHash, entropy });
                 await this._updateUI('cognito', `Origin for ${agentId}: ${originHash.substring(0,8)}...`, 'origin');
            }
            await this._updateUI('cognito', 'All Agent Origins created.', 'origin', 'done');
            this.sessionData.agentOrigins = origins;
        }

        async _step3_deconstructPrompt() {
            await this._updateUI('relay', 'Deconstructing prompt into intents...', 'event');
            const event = { id: `event_${Date.now()}`, timestamp: Date.now(), prompt: this.sessionData.prompt, intents: ['code_generation', 'optimization'], delegation: this.sessionData.agentOrigins.map(a => a.id) };
            await this._updateUI('relay', `Prompt deconstructed. Event ID: ${event.id}`, 'event', 'done');
            this.sessionData.eventStack = [event];
        }

        async _step4_parallelReasoning() {
            await this._updateUI('sentinel', 'Initiating Parallel Fractal Reasoning...', 'fragment');
            await this._updateUI('echo', 'Generating token chunks...', 'fragment');
            
            const reasoningPromises = this.sessionData.agentOrigins.map(agent => this._simulateReasoning(agent));
            const fragments = await Promise.all(reasoningPromises);
            
            await this._updateUI('sentinel', `${fragments.length} fragments generated.`, 'fragment', 'done');
            await this._updateUI('echo', 'Token pool populated.', 'fragment', 'done');
            this.sessionData.fragments = fragments;
        }

        async _simulateReasoning(agent) {
            await new Promise(r => setTimeout(r, 500 + Math.random() * 500));
            const mockCode = `// Agent: ${agent.id}\n// Origin Entropy: ${agent.entropy.toFixed(4)}\nfunction ${agent.id}_solution() {\n  // Solves: ${this.sessionData.prompt.substring(0,30)}...\n  console.log("Processing context of length ${this.sessionData.context.length}");\n  return "completed";\n}`;
            return { agentId: agent.id, content: mockCode, entropy: this._calculateEntropy(mockCode), originHash: agent.hash };
        }

        async _step5_memoryStaging() {
            await this._updateUI('nexus', 'Staging memory with Genesis Counter...', 'genesis');
            this.sessionData.memoryCounter++;
            const memoryCounter = this.sessionData.memoryCounter;
            for(const origin of this.sessionData.agentOrigins) {
                origin.rehashed = await this._sha256(origin.hash + this.sessionData.genesisHash + memoryCounter);
            }
            await this._updateUI('nexus', `Memory staged at version ${memoryCounter}.`, 'genesis', 'done');
            this.sessionData.memoryVersion = memoryCounter;
        }

        async _step6_accelerateReasoning() {
            await this._updateUI('cognito', 'Accelerating reasoning based on entropy...', 'origin');
            this.sessionData.fragments.sort((a, b) => b.entropy - a.entropy);
            await this._updateUI('cognito', `Fragments sorted. Highest entropy: ${this.sessionData.fragments[0].entropy.toFixed(4)}`, 'origin', 'done');
        }
        
        async _step7_enforceCollaboration() {
            await this._updateUI('cognito', 'Enforcing agent collaboration...', 'origin');
            // This is a simulation; in a real scenario, this would involve merging or modifying fragments.
            await this._updateUI('cognito', 'Collaboration graph updated.', 'origin', 'done');
        }

        async _step8_injectThinking() {
            await this._updateUI('relay', 'Injecting realstream thinking into editor...', 'event');
            // This is a simulation; in a real scenario, this would update the UI or a temporary buffer.
            await this._updateUI('relay', 'Thinking stream finalized.', 'event', 'done');
        }

        async _step9_sourceFinalAnswer() {
            await this._updateUI('echo', 'Sourcing final answer from highest-entropy fragment...', 'consensus');
            const bestFragment = this.sessionData.fragments[0];
            await this._updateUI('echo', `Candidate sourced from ${bestFragment.agentId}.`, 'consensus', 'done');
            this.sessionData.bestFragment = bestFragment;
        }

        async _step10_integrateTokens() {
            await this._updateUI('echo', 'Integrating tokens using cyclic math-based method...', 'consensus');
            const bestFragment = this.sessionData.bestFragment;
            const finalCode = `/* === QUANTUM FRACTAL AI CONSENSUS === */\n/* Genesis Root: ${this.sessionData.genesisHash.substring(0,16)}... */\n/* Winning Agent: ${bestFragment.agentId} | Entropy: ${bestFragment.entropy.toFixed(4)} */\n\n${bestFragment.content}`;
            await this._updateUI('echo', 'Final script concatenated.', 'consensus', 'done');
            this.sessionData.finalCode = finalCode;
        }
        
        async _step11_verifyGenesisChain() {
            await this._updateUI('nexus', 'Verifying Genesis Chain...', 'genesis');
            const allValid = this.sessionData.fragments.every(f => f.originHash); 
            await this._updateUI('nexus', `Chain Integrity: ${allValid ? 'OK' : 'FAIL'}.`, 'genesis', 'done');
        }

        async _step12_and_13_consensusAndEntropy() {
            await this._updateUI('sentinel', 'Analyzing multi-dimensional entropy...', 'fragment');
            const fragments = this.sessionData.fragments;
            const avgEntropy = fragments.reduce((sum, f) => sum + f.entropy, 0) / fragments.length;
            await this._updateUI('sentinel', `Average Fragment Entropy: ${avgEntropy.toFixed(4)}`, 'fragment', 'done');

            await this._updateUI('cognito', 'Calculating collaborative consensus score...', 'origin');
            const consensusScore = fragments[0].entropy * fragments.length * avgEntropy;
            await this._updateUI('cognito', `Consensus Score: ${consensusScore.toFixed(2)}`, 'origin', 'done');
            this.sessionData.consensus = { score: consensusScore, averageEntropy: avgEntropy };
        }

        async _step14_verifyPromptAlignment() {
            await this._updateUI('relay', 'Verifying prompt alignment...', 'event', 'done');
        }

        async _step15_validateCodeQuality() {
            await this._updateUI('echo', 'Validating code quality and syntax...', 'consensus', 'done');
        }

        async _step16_optimizePerformance() {
            await this._updateUI('sentinel', 'Applying performance optimization layer...', 'fragment', 'done');
            // This is a placeholder; a real implementation would use code analysis.
        }

        async _step17_assessSecurity() {
            await this._updateUI('sentinel', 'Performing security vulnerability assessment...', 'fragment', 'done');
        }

        async _step18_generateDocumentation() {
            await this._updateUI('echo', 'Generating documentation artifacts...', 'consensus');
            const doc = `/**\n * Auto-generated by Quantum Fractal AI (Nemodian 2244-1).\n * This code was generated in response to the prompt:\n * "${this.sessionData.prompt}"\n * Genesis chain and agent consensus have been validated.\n */`;
            await this._updateUI('echo', 'Documentation generated.', 'consensus', 'done');
            this.sessionData.documentation = doc;
        }

        async _step19_integrateUX() {
            await this._updateUI('relay', 'Verifying UX integration and error handling...', 'event', 'done');
        }
        
        async _step20_archiveSession() {
            await this._updateUI('nexus', 'Archiving orchestration session...', 'genesis', 'done');
            // Using the fully populated this.sessionData
            await memoryManager.store(`session_${this.sessionData.genesisHash}`, this.sessionData, 'high');

            await this._updateUI('cognito', 'Updating knowledge base...', 'origin', 'done');
            await this._updateUI('relay', 'Session report produced.', 'event', 'done');
            await this._updateUI('sentinel', 'Session archived.', 'fragment', 'done');
            
            const finalHtml = `${this.sessionData.documentation}\n\n${this.sessionData.finalCode}`;
            window.quantumConsensusCode = finalHtml;
            
            const highlightedCode = this.highlighter.highlightText(finalHtml, quantumEditor.currentFileType);
            const finalButtons = `<div class="action-buttons">
                <button class="small success" onclick="quantumCopyEnhancedConsensus()">Copy Code</button>
                <button class="small info" onclick="quantumApplyEnhancedConsensus()">Apply to Editor</button>
            </div>`;
            this._updateUI('echo', `<strong>Final Output:</strong><pre style="background: #1a1a1a; padding: 10px; border-radius: 4px; overflow: auto; max-height: 200px;">${this.highlighter.escapeHtml(highlightedCode)}</pre>${finalButtons}`, 'consensus', 'done');

            this.consensusScore.textContent = `Score: ${this.sessionData.consensus.score.toFixed(2)}`;
            this.candidatesList.innerHTML = this.sessionData.fragments.map((frag, index) => `
                <div class="candidate-item ${index === 0 ? 'selected-candidate' : ''}">
                    <div class="candidate-meta">
                        <span>Agent: ${frag.agentId.replace('_', ' ')}</span>
                        <span class="entropy-badge">Entropy: ${frag.entropy.toFixed(4)}</span>
                    </div>
                    <div class="candidate-content">${this.highlighter.escapeHtml(frag.content.substring(0, 150))}...</div>
                </div>
            `).join('');
            this.consensusPanel.style.display = 'block';

            console.log("Final Session Data:", this.sessionData);
        }
    }
    
    // Global functions for button clicks
    function quantumCopyEnhancedConsensus() {
        if (window.quantumConsensusCode) {
            navigator.clipboard.writeText(window.quantumConsensusCode).then(() => {
                quantumNotify('Consensus code copied!', 'success');
            });
        }
    }
    function quantumApplyEnhancedConsensus() {
        if (window.quantumConsensusCode) {
            quantumEditor.setContent(window.quantumConsensusCode, quantumEditor.currentFileType);
            quantumNotify('Consensus code applied!', 'success');
        }
    }


    // App Initialization
    let quantumEditor, enhancedOrchestrator, memoryManager;
    document.addEventListener('DOMContentLoaded', () => {
        try {
            memoryManager = new QuantumMemoryManager();
            quantumEditor = new QuantumEditor();
            enhancedOrchestrator = new EnhancedQuantumOrchestrator();
            
            // --- EVENT LISTENERS ---
            document.getElementById('open-file').addEventListener('click', () => document.getElementById('file-input').click());
            document.getElementById('file-input').addEventListener('change', (e) => handleFileOpen(e));
            document.getElementById('save-file').addEventListener('click', quantumSaveFile);
            document.getElementById('save-as').addEventListener('click', quantumSaveAsFile);
            document.getElementById('send-button').addEventListener('click', runQuantumAI);
            document.getElementById('run-local-ai').addEventListener('click', runQuantumAI);
            document.getElementById('run-orchestrator').addEventListener('click', () => enhancedOrchestrator.runOrchestration(document.getElementById('prompt-input').value, quantumEditor.getContent()));
            document.getElementById('render-html').addEventListener('click', renderQuantumHTML);
            document.getElementById('close-preview').addEventListener('click', () => document.getElementById('preview-panel').style.display = 'none');
            document.getElementById('close-ai-panel').addEventListener('click', () => document.getElementById('ai-response-panel').style.display = 'none');
            document.getElementById('left-toggle').addEventListener('click', () => document.getElementById('editor-stage').classList.toggle('left-panel-open'));
            document.getElementById('btn-undo').addEventListener('click', () => quantumEditor.undo());
            document.getElementById('btn-redo').addEventListener('click', () => quantumEditor.redo());
            document.getElementById('btn-beautify').addEventListener('click', () => quantumEditor.beautifyCode());
            document.getElementById('btn-render').addEventListener('click', renderQuantumHTML);
            document.getElementById('btn-orchestrate').addEventListener('click', runQuantumAI);

            // Quantum Actions
            document.getElementById('btn-optimize').addEventListener('click', () => runQuantumAction('optimize'));
            document.getElementById('btn-document').addEventListener('click', () => runQuantumAction('document'));
            document.getElementById('btn-refactor').addEventListener('click', () => runQuantumAction('refactor'));

            // Memory Management
            document.getElementById('btn-clear-cache').addEventListener('click', () => {
                memoryManager.clearAllCache().then(success => quantumNotify(success ? 'All caches cleared.' : 'Failed to clear caches.', success ? 'success' : 'error'));
            });
            document.getElementById('btn-optimize-memory').addEventListener('click', () => {
                memoryManager.aggressiveCleanup();
                quantumNotify('Aggressive memory cleanup initiated.', 'info');
            });
            document.getElementById('btn-export-session').addEventListener('click', () => {
                memoryManager.exportSession().then(success => quantumNotify(success ? 'Session exported.' : 'Failed to export session.', success ? 'success' : 'error'));
            });
            
            // Settings Listeners
            const settingsToBind = [
                { id: 'quantum-mode', key: 'quantumMode', type: 'checkbox' },
                { id: 'hyperthreading', key: 'hyperthreading', type: 'checkbox' },
                { id: 'multi-agent-mode', key: 'multiAgentMode', type: 'checkbox' },
                { id: 'auto-save', key: 'autoSave', type: 'checkbox' },
                { id: 'agent-count', key: 'agentCount', type: 'number' },
                { id: 'max-rounds', key: 'maxRounds', type: 'number' },
                { id: 'reasoning-depth', key: 'reasoningDepth', type: 'number' },
            ];
            settingsToBind.forEach(setting => {
                const el = document.getElementById(setting.id);
                el.addEventListener('change', (e) => {
                    const value = setting.type === 'checkbox' ? e.target.checked : parseInt(e.target.value, 10);
                    window.quantumState.settings[setting.key] = value;
                    memoryManager.saveSettings();
                    quantumNotify(`Setting '${setting.key}' updated.`, 'info');
                });
            });


            quantumNotify('Quantum Fractal AI Editor Initialized', 'success');
        } catch(e) {
            console.error(e);
            quantumNotify('Initialization Failed', 'error');
        }
    });
    
    function runQuantumAI() {
        const prompt = document.getElementById('prompt-input').value;
        if (!prompt.trim()) {
            quantumNotify('Please enter a prompt.', 'warn');
            return;
        }
        enhancedOrchestrator.runOrchestration(prompt, quantumEditor.getContent());
    }

    function runQuantumAction(actionType) {
        const selectedCode = quantumEditor.getSelectedText();
        if (!selectedCode || selectedCode.trim().length < 10) {
            quantumNotify('Please select some code (or have substantial content) to run an action.', 'warn');
            return;
        }

        let prompt = '';
        switch(actionType) {
            case 'optimize':
                prompt = `Optimize the following code for maximum performance and efficiency:\n\n\`\`\`${quantumEditor.currentFileType}\n${selectedCode}\n\`\`\``;
                break;
            case 'document':
                prompt = `Add detailed JSDoc-style documentation to the following code. Explain what each function does, its parameters, and what it returns:\n\n\`\`\`${quantumEditor.currentFileType}\n${selectedCode}\n\`\`\``;
                break;
            case 'refactor':
                prompt = `Refactor the following code to improve readability, maintainability, and to follow modern best practices:\n\n\`\`\`${quantumEditor.currentFileType}\n${selectedCode}\n\`\`\``;
                break;
            default:
                quantumNotify('Unknown quantum action.', 'error');
                return;
        }

        document.getElementById('prompt-input').value = prompt;
        runQuantumAI();
    }
    
    function quantumNotify(message, type = 'info') {
        const notification = document.createElement('div');
        notification.textContent = message;
        notification.style.cssText = `
            position: fixed; top: 20px; right: 20px;
            background: ${type === 'success' ? 'var(--accent)' : type === 'warn' ? 'var(--warn-bg)' : type === 'error' ? 'var(--err)' : 'var(--info)'};
            color: ${type === 'warn' ? '#3a3c31' : 'white'};
            padding: 10px 15px; border-radius: 4px; z-index: 1000; font-size: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        `;
        document.body.appendChild(notification);
        setTimeout(() => document.body.removeChild(notification), 3000);
    }

    function handleFileOpen(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
            const content = ev.target.result;
            const fileType = quantumEditor.highlighter.detectLanguage(file.name);
            quantumEditor.setContent(content, fileType);
            document.getElementById('file-meta').textContent = file.name;
            quantumEditor.currentFileName = file.name;
            memoryManager.addRecentFile(file.name, content);
        };
        reader.readAsText(file);
    }
    
    function quantumSaveFile() {
        if (!quantumEditor.currentFileName) return quantumSaveAsFile();
        const blob = new Blob([quantumEditor.getContent()], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = quantumEditor.currentFileName;
        a.click();
        URL.revokeObjectURL(a.href);
        quantumNotify('File saved', 'success');
    }
    
    function quantumSaveAsFile() {
        const fileName = prompt('Enter file name:', 'untitled.js');
        if (fileName) {
            quantumEditor.currentFileName = fileName;
            quantumSaveFile();
        }
    }
    
    function renderQuantumHTML() {
        const blob = new Blob([quantumEditor.getContent()], {type: 'text/html'});
        const previewContent = document.getElementById('preview-content');
        if (previewContent.src.startsWith('blob:')) {
            URL.revokeObjectURL(previewContent.src);
        }
        previewContent.src = URL.createObjectURL(blob);
        document.getElementById('preview-panel').style.display = 'flex';
    }

</script>
</body>
</html>